/*
 ============================================================================
 Name        : main.c
 Author      : Irshad
 Version     :
 Copyright   : Template file
 Description : FreeRTOS and Segger RTT Interrupt activity
 ============================================================================
 */


#include <stdio.h>

#include "system_config.h"

#include "FreeRTOS.h"

#include "task.h"

#define Notify_From_Thread

//#define Notify_From_Handler

#define Segger_Trace_Print 1

TaskHandle_t xTaskHandle1;

TaskHandle_t xTaskHandle2;

uint32_t Notification_Value;

void VTask1_handler (void * params);

void VTask2_handler (void * params);

void PrintMessage(char * params);

#define TRUE 1

#define FALSE 0

#define AVAILABLE TRUE

#define NOT_AVAILABLE FALSE

uint8_t UART_KEY = 1;

void Timer_Handler(void);

void OpenDomain(void);

void TimerInit(void);


static void prvSetupHardware(void){

		REG_SETF(CRG_TOP, CLK_AMBA_REG, HCLK_DIV, 0);

		REG_SETF(CRG_TOP, CLK_AMBA_REG, PCLK_DIV, 0);

		REG_SETF(CRG_TOP,PMU_CTRL_REG,COM_SLEEP,0);

		while(!REG_GETF(CRG_TOP,SYS_STAT_REG,COM_IS_UP));

		REG_SETF(CRG_TOP,PMU_CTRL_REG,PERIPH_SLEEP,0);

		while(!REG_GETF(CRG_TOP,SYS_STAT_REG,PER_IS_UP));

		REG_SETF(CRG_TOP, CLK_CTRL_REG, SYS_CLK_SEL,0);

		REG_SETF(GPREG,SET_FREEZE_REG,FRZ_SYS_WDOG,1);

		while (!REG_GETF(CRG_TOP, CLK_CTRL_REG, RUNNING_AT_XTAL32M));

		OpenDomain();

        REG_SETF(CRG_COM,CLK_COM_REG,UART_ENABLE,1);

        UART->UART_SRR_REG = 0x7;

        REG_SETF(UART,UART_LCR_REG,UART_DLAB,1);

        UART->UART_DLF_REG = (0xFF & 0x00001106);

        UART->UART_RBR_THR_DLL_REG = (0xFF & (0x00001106 >> 8));

        UART->UART_IER_DLH_REG = (0xFF & (0x00001106 >> 16));

        UART->UART_LCR_REG = 3; // no parity, 1 stop bit 8 data length and clear UART_DLAB to 0

        GPIO->P0_09_MODE_REG = 2; // UART TX

        TimerInit();
}

void PrintMessage(char * params){

        while(*params!=0){

                while((UART->UART_LSR_REG&0x20)==0);

                UART->UART_RBR_THR_DLL_REG = (0xFF&(*params));

                while((UART->UART_LSR_REG&0x40)==0);

                params++;
        }
}

int main(void){

        DWT->CTRL |= 1<<0; // Cycle counting bit of ARM

        prvSetupHardware();

		#ifdef Segger_Trace_Print

        SEGGER_SYSVIEW_Conf();

        SEGGER_SYSVIEW_Start();

		#endif

        xTaskCreate(VTask1_handler, "First_Task",130 ,NULL,2,&xTaskHandle1 );

        xTaskCreate(VTask2_handler, "Second_Task",130 ,NULL,2,&xTaskHandle2);

        vTaskStartScheduler();

        for(;;);
}



void TimerInit(void){

        TIMER->TIMER_CTRL_REG = 0;    // Disable TIMER block

        NVIC_DisableIRQ(TIMER_IRQn);  // Disable TIMER interrupt

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_EN,0);    // Disable TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_CLK_EN,0);   // Disable the clock to the TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_IRQ_EN,1); // Enable interrupts to be generated by TIMER

        TIMER->TIMER_PRESCALER_REG = 31;  // DIVN / (prescaler + 1)

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_SYS_CLK_EN,0x1);   // TIMER uses the DIVN clock

        TIMER->TIMER_RELOAD_REG = 500001; // interrupt generation every 500 milli seconds

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_ONESHOT_MODE_EN,0x0);  // Counter mode enabled - Counter Refills when limit exceeded

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_COUNT_DOWN_EN,0x0);    // TIMER counts up

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_FREE_RUN_MODE_EN,0);  // Disable free run mode

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_CLK_EN,1); // Enable TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_EN,1); // Enable the TIMER block

        TIMER->TIMER_CLEAR_IRQ_REG = 1; // Acknowledge TIMER IRQ

        NVIC_EnableIRQ(TIMER_IRQn);

        NVIC_SetPriority(TIMER_IRQn, 5); // Higher priority on UART
}

void OpenDomain(void){

    REG_SETF(CRG_TOP,PMU_CTRL_REG, COM_SLEEP,0);   // exit communication P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,COM_IS_UP)==0);

    REG_SETF(CRG_TOP,PMU_CTRL_REG, TIM_SLEEP,0);       // exit timers P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,TIM_IS_UP)==0);

    REG_SETF(CRG_TOP,PMU_CTRL_REG, PERIPH_SLEEP,0);        // exit peripheral P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,PER_IS_UP)==0);

}

#ifdef Notify_From_Handler


void VTask1_handler (void * params){

        while(1){

                if(xTaskNotifyWait(0,0,&Notification_Value,portMAX_DELAY)){

                PrintMessage("Notified from Timer handler\r\n");

#ifdef Segger_Trace_Print
                SEGGER_SYSVIEW_Print("Task 1 notified");
#endif

                }
        }

}

void VTask2_handler (void * params){

        while(1){

            PrintMessage("Task2 is operating \r\n");

#ifdef Segger_Trace_Print
            SEGGER_SYSVIEW_Print("Task 2 yields");
#endif

           taskYIELD();
        }

}

void Timer_Handler(void){

		traceISR_ENTER();

		BaseType_t  pxHigherPriorityTaskWoken = pdFALSE;

		TIMER->TIMER_CLEAR_IRQ_REG = 0;

        xTaskGenericNotifyFromISR(xTaskHandle1,0,eNoAction,NULL,&pxHigherPriorityTaskWoken);

        portYIELD_FROM_ISR(pxHigherPriorityTaskWoken);

        traceISR_EXIT();

}

#endif

#ifdef Notify_From_Thread


void VTask1_handler (void * params){

        while(1){

                if(UART_KEY == AVAILABLE){

                UART_KEY = NOT_AVAILABLE;

                PrintMessage("Called from Timer handler\r\n");

#ifdef Segger_Trace_Print
                SEGGER_SYSVIEW_Print("Task 1 Yielded");
#endif
                taskYIELD();

                }
        }

}

void VTask2_handler (void * params){

        while(1){

            if(UART_KEY == AVAILABLE){

            UART_KEY = NOT_AVAILABLE;

            PrintMessage("Task2 is operating \r\n");

#ifdef Segger_Trace_Print
            SEGGER_SYSVIEW_Print("Task 2 yields");
#endif

           taskYIELD();
            }
        }
}

void Timer_Handler(void){

#ifdef Segger_Trace_Print

		traceISR_ENTER();

#endif

		TIMER->TIMER_CLEAR_IRQ_REG = 0;

        UART_KEY = AVAILABLE;

#ifdef Segger_Trace_Print

        traceISR_EXIT();

#endif

}

#endif
