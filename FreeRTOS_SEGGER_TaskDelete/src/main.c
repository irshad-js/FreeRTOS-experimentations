/*
 ============================================================================
 Name        : main.c
 Author      : Irshad
 Version     :
 Copyright   : Template file
 Description : FreeRTOS and Segger RTT TaskNotification APIs
 ============================================================================
 */


#include <stdio.h>

#include "system_config.h"

#include "FreeRTOS.h"

#include "task.h"

#define Segger_Trace_Print 1

TaskHandle_t xTaskHandle1;

TaskHandle_t xTaskHandle2;

void VTask1_handler (void * params);

void VTask2_handler (void * params);

void PrintMessage(char * params);

#define TRUE 1

#define FALSE 0

#define AVAILABLE TRUE

#define NOT_AVAILABLE FALSE

uint8_t UART_KEY = 1;

void Timer_Handler(void);

void OpenDomain(void);

void TimerInit(void);

int DeleteFlag = 0;

static void prvSetupHardware(void){

		REG_SETF(CRG_TOP, CLK_AMBA_REG, HCLK_DIV, 0);

		REG_SETF(CRG_TOP, CLK_AMBA_REG, PCLK_DIV, 0);

		REG_SETF(CRG_TOP,PMU_CTRL_REG,COM_SLEEP,0);

		while(!REG_GETF(CRG_TOP,SYS_STAT_REG,COM_IS_UP));

		REG_SETF(CRG_TOP,PMU_CTRL_REG,PERIPH_SLEEP,0);

		while(!REG_GETF(CRG_TOP,SYS_STAT_REG,PER_IS_UP));

		REG_SETF(CRG_TOP, CLK_CTRL_REG, SYS_CLK_SEL,0);

		REG_SETF(GPREG,SET_FREEZE_REG,FRZ_SYS_WDOG,1);

		while (!REG_GETF(CRG_TOP, CLK_CTRL_REG, RUNNING_AT_XTAL32M));

		OpenDomain();

        REG_SETF(CRG_COM,CLK_COM_REG,UART_ENABLE,1);

        UART->UART_SRR_REG = 0x7;

        REG_SETF(UART,UART_LCR_REG,UART_DLAB,1);

        UART->UART_DLF_REG = (0xFF & 0x00001106);

        UART->UART_RBR_THR_DLL_REG = (0xFF & (0x00001106 >> 8));

        UART->UART_IER_DLH_REG = (0xFF & (0x00001106 >> 16));

        UART->UART_LCR_REG = 3; // no parity, 1 stop bit 8 data length and clear UART_DLAB to 0

        GPIO->P0_09_MODE_REG = 2; // UART TX

        TimerInit();
}

int main(void){

        DWT->CTRL |= 1<<0; // Cycle counting bit of ARM

        prvSetupHardware();

		#ifdef Segger_Trace_Print

        SEGGER_SYSVIEW_Conf();

        SEGGER_SYSVIEW_Start();

		#endif

        xTaskCreate(VTask1_handler, "First_Task",130 ,NULL,2,&xTaskHandle1 );

        xTaskCreate(VTask2_handler, "Second_Task",130 ,NULL,1,&xTaskHandle2 );

        vTaskStartScheduler();

        for(;;);	// The program will not reach here once the scheduler is invoked
}


void PrintMessage(char * params){

        while(*params!=0){

                while((UART->UART_LSR_REG&0x20)==0);

                UART->UART_RBR_THR_DLL_REG = (0xFF&(*params));

                while((UART->UART_LSR_REG&0x40)==0);

                params++;
        }
}


void VTask1_handler (void * params){

        while(1){

        	if(DeleteFlag<11){

                PrintMessage("Task 1 still executes\r\n");

        	}

        	else {

#ifdef Segger_Trace_Print
               SEGGER_SYSVIEW_Print("Task 1 is deleted");
#endif

               vTaskDelete(NULL);	//	NULL is used to indicate that the calling function needs to be deleted
        	}

        }

}

void VTask2_handler (void * params){

#ifdef Segger_Trace_Print
               SEGGER_SYSVIEW_Print("Task 2 is alive");
#endif

           	vTaskDelay(200);

        while(1){

            PrintMessage("Task 2 is unblocked \r\n");

            vTaskDelay(50);
        	}

}

void TimerInit(void){

        TIMER->TIMER_CTRL_REG = 0;    // Disable TIMER block

        NVIC_DisableIRQ(TIMER_IRQn);  // Disable TIMER interrupt

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_EN,0);    // Disable TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_CLK_EN,0);   // Disable the clock to the TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_IRQ_EN,1); // Enable interrupts to be generated by TIMER

        TIMER->TIMER_PRESCALER_REG = 31;  // DIVN / (prescaler + 1)

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_SYS_CLK_EN,0x1);   // TIMER uses the DIVN clock

        TIMER->TIMER_RELOAD_REG = 500001; // interrupt generation every 500 milli seconds

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_ONESHOT_MODE_EN,0x0);  // Counter mode enabled - Counter Refills when limit exceeded

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_COUNT_DOWN_EN,0x0);    // TIMER counts up

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_FREE_RUN_MODE_EN,0);  // Disable free run mode

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_CLK_EN,1); // Enable TIMER block

        REG_SETF(TIMER,TIMER_CTRL_REG,TIM_EN,1); // Enable the TIMER block

        TIMER->TIMER_CLEAR_IRQ_REG = 1; // Acknowledge TIMER IRQ

        NVIC_EnableIRQ(TIMER_IRQn);
}

void OpenDomain(void){

    REG_SETF(CRG_TOP,PMU_CTRL_REG, COM_SLEEP,0);   // exit communication P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,COM_IS_UP)==0);

    REG_SETF(CRG_TOP,PMU_CTRL_REG, TIM_SLEEP,0);       // exit timers P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,TIM_IS_UP)==0);

    REG_SETF(CRG_TOP,PMU_CTRL_REG, PERIPH_SLEEP,0);        // exit peripheral P.D. from sleep

    while ( REG_GETF(CRG_TOP,SYS_STAT_REG,PER_IS_UP)==0);

}

void Timer_Handler(void){

#ifdef Segger_Trace_Print

		traceISR_ENTER();

#endif

		TIMER->TIMER_CLEAR_IRQ_REG = 0;

		DeleteFlag++;

#ifdef Segger_Trace_Print

        traceISR_EXIT();

#endif


}


